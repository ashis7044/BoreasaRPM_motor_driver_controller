#!/usr/bin/env python3
"""
Triple Sensor Data Logger and Plotter
The script reads data from Arduino on serial port for 3 pressure sensors
(CF XGZP6859D + NXP MP3V5004GP + Honeywell MPR), logs to CSV with timestamps,
and plots data in real-time.
CSV format: XGZP_Pressure_cmH2O,XGZP_Temperature_C,MP3V_Pressure_cmH2O,MPR_Pressure_cmH2O
"""

import argparse
import serial
import serial.tools.list_ports
import csv
import datetime
import time
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from matplotlib.widgets import CheckButtons
from collections import deque
import threading
import queue
import sys
import os
from matplotlib.ticker import AutoMinorLocator, MaxNLocator

# Configuration
BAUD_RATE = 115200
MAX_PLOT_POINTS = 200  # Number of points to display on plot
UPDATE_INTERVAL = 100  # Plot update interval in milliseconds
CSV_FILENAME = f"sensor_data_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"

class SensorLogger:
    def __init__(self, port=None, show_cf_xgzp=True, show_temp=True, show_nxp_mp3v=True, show_mpr=True):
        self.port = port
        self.serial_conn = None
        self.data_queue = queue.Queue()
        self.running = False
        
        # Data storage for plotting
        self.timestamps = deque(maxlen=MAX_PLOT_POINTS)
        self.cf_xgzp_pressures = deque(maxlen=MAX_PLOT_POINTS)
        self.temperatures = deque(maxlen=MAX_PLOT_POINTS)
        self.nxp_mp3v_pressures = deque(maxlen=MAX_PLOT_POINTS)
        self.mpr_pressures = deque(maxlen=MAX_PLOT_POINTS)
        
        # Plot toggles
        self.show_cf_xgzp = show_cf_xgzp
        self.show_temp = show_temp
        self.show_nxp_mp3v = show_nxp_mp3v
        self.show_mpr = show_mpr
        # Setup CSV file
        self.setup_csv()
    
    def find_arduino_port(self):
        """Find the Arduino port automatically"""
        ports = serial.tools.list_ports.comports()
        for port in ports:
            if 'Arduino' in port.description or 'USB' in port.description:
                print(f"Found potential Arduino on {port.device}: {port.description}")
                return port.device
        return None
    
    def setup_csv(self):
        """Ensure CSV file has header 'Timestamp,XGZP_Pressure_cmH2O,XGZP_Temperature_C,MP3V_Pressure_cmH2O,MPR_Pressure_cmH2O'"""
        header_line = 'Timestamp,XGZP_Pressure_cmH2O,XGZP_Temperature_C,MP3V_Pressure_cmH2O,MPR_Pressure_cmH2O'
        # If file doesn't exist, create and write header
        if not os.path.exists(CSV_FILENAME):
            with open(CSV_FILENAME, 'w', newline='') as csvfile:
                csvfile.write(header_line + '\n')
            print(f"Created CSV file with header: {CSV_FILENAME}")
        else:
            # Check if header is present
            with open(CSV_FILENAME, 'r', newline='') as csvfile:
                first = csvfile.readline().strip()
                if first != header_line:
                    # Read existing data
                    rest = csvfile.read()
                    # Prepend header
                    with open(CSV_FILENAME, 'w', newline='') as wf:
                        wf.write(header_line + '\n')
                        wf.write(rest)
                    print(f"Inserted missing header into: {CSV_FILENAME}")
    
    def log_data(self, cf_xgzp_pressure, temperature, nxp_mp3v_pressure, mpr_pressure):
        """Log data to CSV file with timestamp"""
        timestamp = datetime.datetime.now()
        timestamp_str = timestamp.strftime('%Y-%m-%d %H:%M:%S,%f')[:-3]  # Include milliseconds
        
        with open(CSV_FILENAME, 'a', newline='') as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow([timestamp_str, cf_xgzp_pressure, temperature, nxp_mp3v_pressure, mpr_pressure])
    
    def reconnect_serial(self):
        """Attempt to reconnect to the serial port"""
        try:
            if self.serial_conn and self.serial_conn.is_open:
                self.serial_conn.close()
                time.sleep(1)
            
            print(f"Attempting to reconnect to {self.port}...")
            self.serial_conn = serial.Serial(
                port=self.port,
                baudrate=BAUD_RATE,
                timeout=1,
                write_timeout=1,
                exclusive=True  # Prevent other applications from accessing the port
            )
            time.sleep(2)  # Wait for Arduino to reset
            print("Reconnection successful!")
            
        except Exception as e:
            print(f"Reconnection failed: {e}")
            self.serial_conn = None
    
    def serial_reader_thread(self):
        """Thread function to read serial data"""
        consecutive_errors = 0
        max_consecutive_errors = 5
        
        while self.running:
            try:
                if self.serial_conn and self.serial_conn.is_open:
                    # Check if data is available
                    if self.serial_conn.in_waiting > 0:
                        line = self.serial_conn.readline().decode('utf-8', errors='replace').strip()
                        if not line:
                            time.sleep(0.005)
                            continue
                        if line == 'READY':
                            continue
                        # Expect 4 comma-separated fields now
                        parts = line.split(',')
                        if len(parts) == 4:
                            try:
                                p_xgzp = float(parts[0]) if parts[0] != 'NAN' else float('nan')
                                t_xgzp = float(parts[1]) if parts[1] != 'NAN' else float('nan')
                                p_mp3v = float(parts[2]) if parts[2] != 'NAN' else float('nan')
                                p_mpr = float(parts[3]) if parts[3] != 'NAN' else float('nan')
                                self.data_queue.put((datetime.datetime.now(), p_xgzp, t_xgzp, p_mp3v, p_mpr))
                                self.log_data(p_xgzp, t_xgzp, p_mp3v, p_mpr)
                            except ValueError:
                                pass
                        else:
                            # Ignore other legacy / error lines
                            pass
                    time.sleep(0.01)
                else:
                    print("Serial connection lost. Attempting to reconnect...")
                    self.reconnect_serial()
                    time.sleep(2)
            except (serial.SerialException, OSError, PermissionError) as e:
                consecutive_errors += 1
                print(f"Serial reading error ({consecutive_errors}/{max_consecutive_errors}): {e}")
                
                if consecutive_errors >= max_consecutive_errors:
                    print("Too many consecutive errors. Attempting to reconnect...")
                    self.reconnect_serial()
                    consecutive_errors = 0
                    time.sleep(2)
                else:
                    time.sleep(1)
                    
            except Exception as e:
                consecutive_errors += 1
                print(f"Unexpected error ({consecutive_errors}/{max_consecutive_errors}): {e}")
                if consecutive_errors >= max_consecutive_errors:
                    print("Too many consecutive errors. Stopping serial thread.")
                    break
                time.sleep(1)
    
    def update_plot_data(self):
        """Update plot data from queue"""
        while not self.data_queue.empty():
            try:
                timestamp, p_xgzp, t_xgzp, p_mp3v, p_mpr = self.data_queue.get_nowait()
                self.timestamps.append(timestamp)
                self.cf_xgzp_pressures.append(p_xgzp)
                self.temperatures.append(t_xgzp)
                self.nxp_mp3v_pressures.append(p_mp3v)
                self.mpr_pressures.append(p_mpr)
            except queue.Empty:
                break
    
    def animate_plot(self, frame):
        """Animation function for matplotlib"""
        self.update_plot_data()
        
        if len(self.timestamps) > 1:
            # Clear and plot pressures based on toggles
            self.ax1.clear()
            if self.show_cf_xgzp:
                self.ax1.plot(self.timestamps, self.cf_xgzp_pressures, 'b-', linewidth=1, label='CF XGZP6859D')
            if self.show_nxp_mp3v:
                self.ax1.plot(self.timestamps, self.nxp_mp3v_pressures, 'g-', linewidth=1, label='NXP MP3V5004GP')
            if self.show_mpr:
                self.ax1.plot(self.timestamps, self.mpr_pressures, 'm-', linewidth=1, label='Honeywell MPR')
            self.ax1.set_ylabel('Pressure (cmH2O)', color='k')
            self.ax1.tick_params(axis='y', labelcolor='k')
            self.ax1.grid(True, which='both', alpha=0.3) # Grid for major and minor ticks
            if any([self.show_cf_xgzp, self.show_nxp_mp3v, self.show_mpr]):
                self.ax1.legend(loc='upper left')
            
            # Add more ticks to the pressure axis
            self.ax1.yaxis.set_major_locator(MaxNLocator(nbins=20, prune='both'))
            self.ax1.yaxis.set_minor_locator(AutoMinorLocator(2))
            
            # Clear and plot temperature based on toggle
            self.ax2.clear()
            if self.show_temp:
                self.ax2.plot(self.timestamps, self.temperatures, 'r-', linewidth=1, label='Temperature')
                self.ax2.legend(loc='upper right')
            self.ax2.set_ylabel('Temperature (°C)', color='r')
            self.ax2.tick_params(axis='y', labelcolor='r')
            self.ax2.yaxis.set_label_position('right')
            self.ax2.yaxis.tick_right()
            
            # Format x-axis
            self.ax1.set_xlabel('Time')
            
            # Rotate x-axis labels for better readability
            plt.setp(self.ax1.xaxis.get_majorticklabels(), rotation=45)
            
            # Set title with current values for enabled sensors
            title_parts = []
            if self.show_cf_xgzp and self.cf_xgzp_pressures:
                title_parts.append(f'XGZP: {self.cf_xgzp_pressures[-1]:.3f}')
            if self.show_nxp_mp3v and self.nxp_mp3v_pressures:
                title_parts.append(f'MP3V: {self.nxp_mp3v_pressures[-1]:.3f}')
            if self.show_mpr and self.mpr_pressures:
                title_parts.append(f'MPR: {self.mpr_pressures[-1]:.3f}')
            if self.show_temp and self.temperatures:
                title_parts.append(f'T: {self.temperatures[-1]:.2f}°C')
            if title_parts:
                self.ax1.set_title('Triple Sensor Data - ' + ', '.join(title_parts))
    
    def start_logging(self):
        """Start the data logging process"""
        # Find and connect to Arduino
        if not self.port:
            self.port = self.find_arduino_port()
            
        if not self.port:
            print("No Arduino port found. Please specify manually.")
            return False
        
        # Check if port is already in use
        try:
            # Try to open and immediately close to test availability
            test_conn = serial.Serial(self.port, BAUD_RATE, timeout=0.1)
            test_conn.close()
            time.sleep(0.5)
        except serial.SerialException as e:
            print(f"Port {self.port} may be in use: {e}")
            return False
        
        try:
            self.serial_conn = serial.Serial(
                port=self.port,
                baudrate=BAUD_RATE,
                timeout=1,
                write_timeout=1,
                exclusive=True,
                rtscts=False,
                dsrdtr=False
            )
            print(f"Connected to Arduino on {self.port}")
            
            # Clear any existing data in the buffer
            self.serial_conn.flushInput()
            self.serial_conn.flushOutput()
            
            time.sleep(2)  # Wait for Arduino to reset
            
        except Exception as e:
            print(f"Error connecting: {e}")
            return False
        
        # Start serial reading thread
        self.running = True
        self.serial_thread = threading.Thread(target=self.serial_reader_thread, daemon=True)
        self.serial_thread.start()
        
        # Setup matplotlib for real-time plotting
        plt.ion()
        self.fig, self.ax1 = plt.subplots(figsize=(14, 8))
        self.ax2 = self.ax1.twinx()
        
        # Adjust subplot to make room for checkboxes
        plt.subplots_adjust(right=0.85)
        
        # Add checkbox controls for toggling plot lines
        checkbox_ax = plt.axes([0.87, 0.6, 0.11, 0.25])
        labels = ['CF XGZP6859D', 'Temperature', 'NXP MP3V5004GP', 'Honeywell MPR']
        visibility = [self.show_cf_xgzp, self.show_temp, self.show_nxp_mp3v, self.show_mpr]
        self.checkboxes = CheckButtons(checkbox_ax, labels, visibility)
        self.checkboxes.on_clicked(self.toggle_plots)
        
        # Style the checkboxes (compatible with different matplotlib versions)
        try:
            # For newer matplotlib versions
            for rect in self.checkboxes.rectangles:
                rect.set_facecolor('lightgray')
                rect.set_edgecolor('black')
        except AttributeError:
            # For older matplotlib versions or different attribute names
            pass
        
        try:
            for line in self.checkboxes.lines:
                line[0].set_color('blue')
                line[1].set_color('blue')
        except (AttributeError, IndexError):
            pass
        
        # Start animation
        self.ani = animation.FuncAnimation(
            self.fig, self.animate_plot, interval=UPDATE_INTERVAL, 
            blit=False, cache_frame_data=False
        )
        
        print("Starting real-time plot. Close the plot window to stop logging.")
        plt.show()
        
        return True
    
    def stop_logging(self):
        """Stop the logging process"""
        print("\nStopping logging...")
        self.running = False
        
        # Wait for the serial thread to finish
        if hasattr(self, 'serial_thread') and self.serial_thread.is_alive():
            self.serial_thread.join(timeout=2)
        
        # Close serial connection
        if self.serial_conn and self.serial_conn.is_open:
            try:
                self.serial_conn.close()
                print("Serial connection closed successfully")
            except Exception as e:
                print(f"Error closing serial connection: {e}")
        
        print(f"Data saved to {CSV_FILENAME}")

    def toggle_plots(self, label):
        """Callback function for checkbox toggles"""
        if label == 'CF XGZP6859D':
            self.show_cf_xgzp = not self.show_cf_xgzp
        elif label == 'Temperature':
            self.show_temp = not self.show_temp
        elif label == 'NXP MP3V5004GP':
            self.show_nxp_mp3v = not self.show_nxp_mp3v
        elif label == 'Honeywell MPR':
            self.show_mpr = not self.show_mpr

def list_serial_ports():
    """List available serial ports"""
    ports = serial.tools.list_ports.comports()
    print("Available serial ports:")
    for i, port in enumerate(ports):
        print(f"  {i}: {port.device} - {port.description}")
    return ports

def check_port_availability(port):
    """Check if a serial port is available for exclusive use"""
    try:
        # Try to open with exclusive access
        test_conn = serial.Serial(
            port=port,
            baudrate=115200,
            timeout=0.1,
            exclusive=True
        )
        test_conn.close()
        return True, "Port is available"
    except serial.SerialException as e:
        if "PermissionError" in str(e) or "Access is denied" in str(e):
            return False, "Port is being used by another application"
        else:
            return False, f"Port error: {e}"
    except Exception as e:
        return False, f"Unexpected error: {e}"

def main():
    parser = argparse.ArgumentParser(description="Triple Sensor Data Logger")
    parser.add_argument('port', nargs='?', help='Serial port (e.g., COM3)')
    parser.add_argument('--disable-cf-xgzp', action='store_true')
    parser.add_argument('--disable-temp', action='store_true')
    parser.add_argument('--disable-nxp-mp3v', action='store_true')
    parser.add_argument('--disable-mpr', action='store_true')
    args = parser.parse_args()

    print("Triple Sensor Data Logger")
    print("XGZP6859D + MP3V5004GP + Honeywell MPR")
    print("=" * 40)
    ports = list_serial_ports()
    if not ports:
        print("No serial ports found!")
        return
    show_cf_xgzp = not args.disable_cf_xgzp
    show_temp = not args.disable_temp
    show_nxp_mp3v = not args.disable_nxp_mp3v
    show_mpr = not args.disable_mpr
    logger = SensorLogger(port=args.port, show_cf_xgzp=show_cf_xgzp, show_temp=show_temp, show_nxp_mp3v=show_nxp_mp3v, show_mpr=show_mpr)
    if not args.port:
        auto_port = logger.find_arduino_port()
        if auto_port:
            logger.port = auto_port
        else:
            print("\nCould not auto-detect Arduino. Please select a port:")
            try:
                choice = int(input("Enter port number: "))
                if 0 <= choice < len(ports):
                    logger.port = ports[choice].device
                else:
                    print("Invalid choice!")
                    return
            except ValueError:
                print("Invalid input!")
                return
    print(f"\nUsing port: {logger.port}")
    available, message = check_port_availability(logger.port)
    if not available:
        print(f"Error: {message}")
        return
    print(f"Port check passed: {message}")
    try:
        if logger.start_logging():
            while plt.get_fignums():
                plt.pause(0.1)
    except KeyboardInterrupt:
        print("\nStopped by user")
    finally:
        logger.stop_logging()

if __name__ == "__main__":
    main()
